---
layout: android
title: 知识点补充
tags: ["python","基础知识"]
category: Python
---


DECK: newDeck
# 移位运算符
## 负数二进制表示
计算负数的二进制表示通常涉及到使用补码（Two's complement）的概念。在计算机中，负数通常以补码的形式存储。以下是计算负数的二进制表示的一般步骤：

1. **确定绝对值的二进制表示：**
    - 将负数的绝对值转换为二进制形式。
2. **取绝对值的反码：**
    - 将绝对值的二进制表示中的每一位取反，即将0变为1，将1变为0。
3. **加1：**
    - 将反码加1。

这样得到的结果就是负数的补码。下面以一个例子说明：

**例子：计算-5的二进制表示。**

1. **确定绝对值的二进制表示：**
    - `5` 的二进制表示为 `00000101`。
2. **取绝对值的反码：**
    - 反码为 `11111010`。
3. **加1：**
    - 补码为 `11111011`。
因此，-5 的二进制表示为 `11111011`。这就是使用补码表示负数的方法。在计算机中，这种表示方式有助于简化加法和减法的操作，并且负数的表示是唯一的。

`二进制+1： 1+1 变为0，往前进1 ，直到进到 0+1=1.`
END
<!--ID: 1705648765407-->


## 十进制转二进制
1. **除2取余：**
    - 将要转换的十进制数除以2，记录余数。
    - 将商作为新的被除数，继续除以2，再次记录余数。
    - 重复这个过程，直到商为0。
2. **将余数反序排列：**
    - 从最后一次的余数开始，将所有的余数从下往上排列，得到的就是该十进制数的二进制表示。

```
Step 1: 26 / 2 = 13, 余数是 0
Step 2: 13 / 2 = 6, 余数是 1
Step 3: 6 / 2 = 3, 余数是 0
Step 4: 3 / 2 = 1, 余数是 1
Step 5: 1 / 2 = 0, 余数是 1
```
将得到的余数反序排列：`11010`. 所以，十进制数 26 的二进制表示为 `11010`
END
<!--ID: 1705648765410-->


## 为什么使用32位

在计算机中，负数通常以补码（Two's complement）的形式存储。为了表示有符号整数，Java 使用32位（int）或64位（long）来存储整数，无论是正数还是负数。

对于整数的二进制表示，Java 使用固定位数（例如32位）来存储，因此-8在32位二进制中是以32位进行表示的。

在补码表示法中，一个负数的二进制形式是其绝对值的二进制形式取反（得到反码），然后加1。例如，-8 的二进制表示：

1. 将 8 的二进制表示取反： `00000000 00000000 00000000 00001000` 取反为 `11111111 11111111 11111111 11110111`
2. 加1： `11111111 11111111 11111111 11110111` + 1 = `11111111 11111111 11111111 11111000`
END
<!--ID: 1705648765414-->



## 移位运算符  [Bitwise Right Shift Operators in Java](https://www.geeksforgeeks.org/bitwise-shift-operators-in-java/)
java中有三种移位运算符

```
<<  :左移运算符，num << 1,  相当于num乘以2
>>  :右移运算符，num >> 1,  相当于num除以2
>>> :无符号右移，忽略符号位，空位都以0补齐
```

### `>>` 右移运算符（有符号右移）：

- 作用：将二进制表示的数向右移动指定的位数，空位补符号位（正数补0，负数补1）。
```
int x = -8;
int result = x >> 2;  // 结果是 -2
```
- `-8` 的二进制表示为 `11111111111111111111111111111000`。
- 将其右移两位，得到 `11111111111111111111111111111110`，即 `-2`。
 （自创上述二进制简便算法：从最右边0开始，数到第一个1，再转成十进制，即为它的值，再看左边第一位符号位，如果是1，则加上负号，如果是0，则为正数。
	 例如：1...1000 为 - 1*2^3 = -8
 ）

### `>>>`无符号右移运算符
将32位二进制表示的数向右移动指定的位数，不考虑符号位，无论正负，空位都以0补上。
```java
class GFG {  
    // main driver method  
    public static void main(String args[]) {  
        // x is stored using 32 bit 2's complement form.  
        // 1的二进制是00000001,以32位储存为00000000 00000000 00000000 00000001  
        // 负数取反：11111111 11111111 11111111 11111110  
        // 补码加1： 11111111 11111111 11111111 11111111  
        // Binary representation of -1 is all 1s        
        int x = -1;  
  
        // 向右移动29位，表示从右到左的29位数都被去掉，最左边的3位111 移到了右边，前面以0补齐  
        // 32-29=3 , 表示只留下了最左边3位数，再以0在前面补齐  
  
        // The value of 'x>>>29' is 00000000 00000000 00000000 00000111  
        System.out.println(x >>> 29);  // 7  
  
        // The value of 'x>>>30' is 00...00000011        
        System.out.println(x >>> 30); // 3  
  
        // The value of 'x>>>31' is 00...00000001        
        System.out.println(x >>> 31); // 1  
  
    }  
}
```

综上，`>>` 用于有符号右移，而 `>>>` 用于无符号右移。在处理正数时，它们的效果是一样的，但在处理负数时，符号位的处理方式不同。

- **Time Complexity:** O(1).

- **Space Complexity:** O(1) as no extra space has been used.
END
<!--ID: 1705648765417-->

## 曾国藩语录
- ![[Pasted image 20240119233304.png]]
### 123 
### 有恒则断无不能之事！

- 
END
<!--ID: 1705679093885-->



































